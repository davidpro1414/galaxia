<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Galaxia del Amor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        body, html {
            margin: 0;
            height: 100%;
            background: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .player {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 18px;
            border: 2px solid rgba(180, 100, 220, 0.6);
            border-radius: 999px;
            background: rgba(20, 10, 40, 0.7);
            backdrop-filter: blur(10px);
            box-shadow: 
                0 0 20px rgba(138, 43, 226, 0.5),
                0 0 40px rgba(255, 105, 180, 0.3),
                0 0 60px rgba(135, 206, 250, 0.2),
                inset 0 0 20px rgba(180, 100, 220, 0.1);
            z-index: 1000;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: #fff;
            font-size: 14px;
            animation: playerGlow 4s ease-in-out infinite;
        }

        @keyframes playerGlow {
            0%, 100% { 
                box-shadow: 
                    0 0 20px rgba(138, 43, 226, 0.5),
                    0 0 40px rgba(255, 105, 180, 0.3),
                    0 0 60px rgba(135, 206, 250, 0.2),
                    inset 0 0 20px rgba(180, 100, 220, 0.1);
            }
            50% { 
                box-shadow: 
                    0 0 25px rgba(255, 105, 180, 0.6),
                    0 0 50px rgba(135, 206, 250, 0.4),
                    0 0 70px rgba(138, 43, 226, 0.3),
                    inset 0 0 25px rgba(255, 105, 180, 0.15);
            }
        }

        .player button {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.3), rgba(255, 105, 180, 0.3));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            filter: drop-shadow(0 0 8px rgba(180, 100, 220, 0.8));
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player button:hover {
            transform: scale(1.15);
            background: linear-gradient(135deg, rgba(255, 105, 180, 0.5), rgba(135, 206, 250, 0.5));
            filter: drop-shadow(0 0 15px rgba(255, 105, 180, 0.9));
        }

        .player button.small {
            width: 34px;
            height: 34px;
            font-size: 14px;
        }

        .player-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .track-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .song-title {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.85);
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 0 0 5px rgba(180, 100, 220, 0.6);
        }

        .progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 999px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            border: 1px solid rgba(180, 100, 220, 0.3);
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, 
                #8a2be2,   /* Violeta */
                #ff69b4,   /* Rosa */
                #87ceeb,   /* Celeste */
                #ff69b4,   /* Rosa */
                #8a2be2    /* Violeta */
            );
            background-size: 300% 100%;
            border-radius: 999px;
            box-shadow: 0 0 10px rgba(255, 105, 180, 0.8);
            animation: flowingColors 4s ease infinite;
        }

        @keyframes flowingColors {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        footer{
            position: fixed;
            bottom: 5px;
            right: 10px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        .time {
            min-width: 80px;
            text-align: right;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 8px rgba(180, 100, 220, 0.8);
            font-weight: 500;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <div class="player">
        <div class="player-controls">
            <button id="prev" class="small"><i class="fa-solid fa-backward-step"></i></button>
            <button id="play"><i class="fa-solid fa-play"></i></button>
            <button id="next" class="small"><i class="fa-solid fa-forward-step"></i></button>
        </div>
        <div class="track-info">
            <div class="song-title" id="song-title">The Weeknd - Die For You</div>
            <div class="progress" id="progress">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>
        <div class="time" id="time">0:00 / 0:00</div>
    </div>

    <audio id="audio"></audio>

    <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>

    <script>

        const playlist = [
            {
                title: "The Weeknd - Die For You",
                url: "musica/The Weeknd.mp3"
            },
            {
                title: "Binomio De Oro - Ni√±a Bonita",
                url: "musica/Ni√±a Bonita.mp3"
            }

             ,  {
                title: "Grover Washington JR. - Just the two of us",
                url: "musica/Grover Washington JR.mp3"
            },

            ,  {
                title: "Maelo Ruiz - AsiÃÅ Eres TuÃÅ",
                url: "musica/Asi Eres T.mp3"
            },

                ,  {
                title: "Segundo Rosero - Estoy De Ti Enamorado",
                url: "musica/Segundo Rosero .mp3"
            }

        ];

        let currentTrack = 0;

        // ===== REPRODUCTOR DE AUDIO =====
        const audio = document.getElementById("audio");
        const playBtn = document.getElementById("play");
        const prevBtn = document.getElementById("prev");
        const nextBtn = document.getElementById("next");
        const progress = document.getElementById("progress");
        const progressBar = document.getElementById("progress-bar");
        const timeDisplay = document.getElementById("time");

        let isPlaying = false;

        // ===== ANALIZADOR DE AUDIO =====
        let audioContext, analyser, dataArray, source;
        let audioReactivity = 0;

        function initAudioAnalyser() {
            if (audioContext) return;
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            
            source = audioContext.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function getAudioLevel() {
            if (!analyser) return 0;
            
            analyser.getByteFrequencyData(dataArray);
            
            // Promedio de frecuencias bajas-medias (m√°s impacto visual)
            let sum = 0;
            for (let i = 0; i < 64; i++) {
                sum += dataArray[i];
            }
            return sum / 64 / 255; // Normalizado 0-1
        }

        // ===== CARGAR CANCI√ìN =====
        const songTitleEl = document.getElementById("song-title");

        function loadTrack(index) {
            if (index < 0) index = playlist.length - 1;
            if (index >= playlist.length) index = 0;
            currentTrack = index;
            
            audio.src = playlist[currentTrack].url;
            audio.load();
            songTitleEl.textContent = playlist[currentTrack].title;
            
            if (isPlaying) {
                audio.play();
            }
        }

        // Cargar primera canci√≥n
        loadTrack(0);

        function formatTime(e) {
            if (!isFinite(e)) return "0:00";
            return Math.floor(e / 60) + ":" + Math.floor(e % 60).toString().padStart(2, "0");
        }

        playBtn.addEventListener("click", async () => {
            initAudioAnalyser();
            
            if (isPlaying) {
                audio.pause();
                playBtn.innerHTML = '<i class="fa-solid fa-play"></i>';
            } else {
                await audio.play();
                playBtn.innerHTML = '<i class="fa-solid fa-pause"></i>';
            }
            isPlaying = !isPlaying;
        });

        prevBtn.addEventListener("click", () => {
            loadTrack(currentTrack - 1);
        });

        nextBtn.addEventListener("click", () => {
            loadTrack(currentTrack + 1);
        });

        // Auto-siguiente canci√≥n
        audio.addEventListener("ended", () => {
            loadTrack(currentTrack + 1);
            if (isPlaying) audio.play();
        });

        audio.addEventListener("timeupdate", () => {
            const percent = (audio.currentTime / audio.duration) * 100;
            progressBar.style.width = (isFinite(percent) ? percent : 0) + "%";
            timeDisplay.textContent = formatTime(audio.currentTime) + " / " + formatTime(audio.duration);
        });

        progress.addEventListener("click", (e) => {
            const rect = progress.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            if (isFinite(audio.duration)) {
                audio.currentTime = pos * audio.duration;
            }
        });

        // ===== CONFIGURACI√ìN DE THREE.JS =====
        const canvas = document.getElementById("c");
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(innerWidth, innerHeight);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 5000);

        let targetDist = 300;
        let currentDist = 300;
        let rotX = 0.2;
        let rotY = 0;

        // ===== FONDO ESPACIAL =====
        const loader = new THREE.TextureLoader();
        const nebulaTex = loader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/space/px.jpg");
        scene.background = nebulaTex;

        // ===== ESTRELLAS =====
        function createStars(count = 2000, radius = 3000) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const dist = radius * (0.3 + 0.7 * Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                positions[i * 3 + 0] = dist * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = dist * Math.cos(phi);
                positions[i * 3 + 2] = dist * Math.sin(phi) * Math.sin(theta);
            }

            geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                color: 0xffffff,
                depthWrite: false
            });

            scene.add(new THREE.Points(geometry, material));
        }
        createStars();

        // ===== ESTRELLAS FUGACES =====
        const shootingStars = [];
        const maxShootingStars = 15;

        function createShootingStar() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(6);
            geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

            const material = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const line = new THREE.Line(geometry, material);
            line.visible = false;

            line.userData = {
                active: false,
                life: 0,
                maxLife: 60 + Math.random() * 40,
                startX: 0, startY: 0, startZ: 0,
                velocityX: 0, velocityY: 0, velocityZ: 0,
                tailLength: 30 + Math.random() * 50
            };

            scene.add(line);
            return line;
        }

        for (let i = 0; i < maxShootingStars; i++) {
            shootingStars.push(createShootingStar());
        }

        function launchShootingStar() {
            const star = shootingStars.find(s => !s.userData.active);
            if (!star) return;

            const data = star.userData;
            data.active = true;
            data.life = 0;
            star.visible = true;

            const side = Math.floor(Math.random() * 4);
            const dist = 800 + Math.random() * 400;

            switch (side) {
                case 0:
                    data.startX = -dist + Math.random() * dist;
                    data.startY = 300 + Math.random() * 200;
                    data.startZ = -dist + Math.random() * dist * 2;
                    break;
                case 1:
                    data.startX = Math.random() * dist;
                    data.startY = 300 + Math.random() * 200;
                    data.startZ = -dist + Math.random() * dist * 2;
                    break;
                case 2:
                    data.startX = -dist / 2 + Math.random() * dist;
                    data.startY = 200 + Math.random() * 300;
                    data.startZ = -dist;
                    break;
                default:
                    data.startX = -dist / 2 + Math.random() * dist;
                    data.startY = 200 + Math.random() * 300;
                    data.startZ = dist;
                    break;
            }

            const speed = 15 + Math.random() * 10;
            const angle = Math.PI / 4 + Math.random() * Math.PI / 6;

            data.velocityX = speed * Math.cos(angle) * (Math.random() > 0.5 ? 1 : -1);
            data.velocityY = -speed * Math.sin(angle);
            data.velocityZ = speed * (Math.random() - 0.5) * 0.5;

            data.tailLength = 40 + Math.random() * 60;
            data.maxLife = 50 + Math.random() * 50;
        }

        function updateShootingStars() {
            shootingStars.forEach(star => {
                const data = star.userData;
                if (!data.active) return;

                data.life++;

                const currentX = data.startX + data.velocityX * data.life;
                const currentY = data.startY + data.velocityY * data.life;
                const currentZ = data.startZ + data.velocityZ * data.life;

                const tailFactor = Math.min(data.life / 10, 1);
                const tailX = currentX - data.velocityX * tailFactor * 3;
                const tailY = currentY - data.velocityY * tailFactor * 3;
                const tailZ = currentZ - data.velocityZ * tailFactor * 3;

                const positions = star.geometry.attributes.position.array;
                positions[0] = tailX;
                positions[1] = tailY;
                positions[2] = tailZ;
                positions[3] = currentX;
                positions[4] = currentY;
                positions[5] = currentZ;
                star.geometry.attributes.position.needsUpdate = true;

                const lifeRatio = data.life / data.maxLife;
                star.material.opacity = lifeRatio > 0.7 ? 0.8 * (1 - (lifeRatio - 0.7) / 0.3) : 0.8;

                if (data.life >= data.maxLife) {
                    data.active = false;
                    star.visible = false;
                }
            });
        }

        // Lanzar estrellas fugaces peri√≥dicamente
        setInterval(() => {
            if (Math.random() < 0.7) launchShootingStar();
        }, 500);

        setTimeout(() => launchShootingStar(), 500);
        setTimeout(() => launchShootingStar(), 1200);

        // ===== N√öCLEO CENTRAL (PULSAR) =====
        const coreMat = new THREE.MeshPhongMaterial({
            color: 0x8844ff,
            emissive: 0x4422aa,
            transparent: true,
            opacity: 0.85,
            shininess: 300
        });
        // Forma de icosaedro para un look m√°s interesante
        const core = new THREE.Mesh(new THREE.IcosahedronGeometry(35, 1), coreMat);
        scene.add(core);

        // ===== HACES DEL PULSAR (POLOS) =====
        function createPulsarBeam() {
            const beamGeometry = new THREE.ConeGeometry(8, 400, 32, 1, true);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            return new THREE.Mesh(beamGeometry, beamMaterial);
        }

        const beamTop = createPulsarBeam();
        beamTop.position.y = 200;
        beamTop.rotation.x = Math.PI;
        scene.add(beamTop);

        const beamBottom = createPulsarBeam();
        beamBottom.position.y = -200;
        scene.add(beamBottom);

        // Glow para los haces
        function makeBeamGlow(size = 512) {
            const canvas = document.createElement("canvas");
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext("2d");

            const gradient = ctx.createRadialGradient(
                size / 2, size / 2, 0,
                size / 2, size / 2, size / 2
            );
            gradient.addColorStop(0, "rgba(150, 200, 255, 0.8)");
            gradient.addColorStop(0.3, "rgba(200, 150, 255, 0.4)");
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        const beamGlowTop = new THREE.Sprite(new THREE.SpriteMaterial({
            map: makeBeamGlow(),
            transparent: true,
            blending: THREE.AdditiveBlending
        }));
        beamGlowTop.scale.set(80, 80, 1);
        beamGlowTop.position.y = 60;
        scene.add(beamGlowTop);

        const beamGlowBottom = new THREE.Sprite(new THREE.SpriteMaterial({
            map: makeBeamGlow(),
            transparent: true,
            blending: THREE.AdditiveBlending
        }));
        beamGlowBottom.scale.set(80, 80, 1);
        beamGlowBottom.position.y = -60;
        scene.add(beamGlowBottom);

        // ===== TEXTO CENTRAL "TE AMO" =====
        function makeCenterTextTexture(text) {
            const canvas = document.createElement("canvas");
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext("2d");

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = "bold 80px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#ff0033";
            ctx.shadowColor = "#ff66aa";
            ctx.shadowBlur = 50;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            return new THREE.CanvasTexture(canvas);
        }

        const centerTex = makeCenterTextTexture("TE AMO ‚ù§Ô∏è");
        const centerMat = new THREE.SpriteMaterial({ map: centerTex, transparent: true });
        const centerSprite = new THREE.Sprite(centerMat);
        centerSprite.scale.set(60, 60, 1);
        centerSprite.position.set(0, 0, 0);
        centerSprite.renderOrder = 999;
        scene.add(centerSprite);

        // ===== RESPLANDOR PULSAR (VIOLETA/ROSA/CELESTE) =====
        function makePulsarGlow(size = 768, phase = 0) {
            const canvas = document.createElement("canvas");
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext("2d");

            // Colores que ciclan: violeta -> rosa -> celeste
            const colors = [
                { r: 138, g: 43, b: 226 },  // Violeta
                { r: 255, g: 105, b: 180 }, // Rosa
                { r: 135, g: 206, b: 250 }  // Celeste
            ];

            const idx1 = Math.floor(phase) % 3;
            const idx2 = (idx1 + 1) % 3;
            const blend = phase - Math.floor(phase);

            const c1 = colors[idx1];
            const c2 = colors[idx2];

            const r1 = Math.round(c1.r + (c2.r - c1.r) * blend);
            const g1 = Math.round(c1.g + (c2.g - c1.g) * blend);
            const b1 = Math.round(c1.b + (c2.b - c1.b) * blend);

            const gradient = ctx.createRadialGradient(
                size / 2, size / 2, 0.02 * size,
                size / 2, size / 2, 0.5 * size
            );
            gradient.addColorStop(0, `rgba(255, 255, 255, 0.95)`);
            gradient.addColorStop(0.15, `rgba(${r1}, ${g1}, ${b1}, 0.85)`);
            gradient.addColorStop(0.4, `rgba(${r1 * 0.7 | 0}, ${g1 * 0.7 | 0}, ${b1 * 0.9 | 0}, 0.5)`);
            gradient.addColorStop(0.7, `rgba(${r1 * 0.4 | 0}, ${g1 * 0.3 | 0}, ${b1 * 0.6 | 0}, 0.2)`);
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        const glowMaterial = new THREE.SpriteMaterial({
            map: makePulsarGlow(768, 0),
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const glow = new THREE.Sprite(glowMaterial);
        glow.scale.set(450, 450, 1);
        scene.add(glow);

        // Segunda capa de resplandor m√°s suave
        const glowMaterial2 = new THREE.SpriteMaterial({
            map: makePulsarGlow(768, 1.5),
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const glow2 = new THREE.Sprite(glowMaterial2);
        glow2.scale.set(600, 600, 1);
        scene.add(glow2);

        // ===== ANILLOS (TONOS VIOLETA/ROSA) =====
        function ringTexture(size = 768) {
            const canvas = document.createElement("canvas");
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext("2d");

            ctx.translate(size / 2, size / 2);

            const innerRadius = 0.34 * size;
            const outerRadius = 0.49 * size;

            const gradient = ctx.createRadialGradient(0, 0, 0.3 * innerRadius, 0, 0, outerRadius);
            gradient.addColorStop(0, "rgba(220, 180, 255, 1)");      // Blanco-violeta
            gradient.addColorStop(0.3, "rgba(180, 100, 220, 0.9)");  // Violeta
            gradient.addColorStop(0.5, "rgba(255, 120, 180, 0.7)");  // Rosa
            gradient.addColorStop(0.75, "rgba(150, 180, 255, 0.4)"); // Celeste
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, outerRadius, 0, 2 * Math.PI);
            ctx.arc(0, 0, innerRadius, 0, 2 * Math.PI, true);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        const ring1 = new THREE.Mesh(
            new THREE.RingGeometry(60, 80, 128),
            new THREE.MeshBasicMaterial({
                map: ringTexture(),
                transparent: true,
                side: THREE.DoubleSide
            })
        );

        const ring2 = new THREE.Mesh(
            new THREE.RingGeometry(85, 100, 128),
            new THREE.MeshBasicMaterial({
                map: ringTexture(),
                transparent: true,
                side: THREE.DoubleSide,
                opacity: 0.6
            })
        );

        ring1.rotation.x = ring2.rotation.x = Math.PI / 2;
        scene.add(ring1);
        scene.add(ring2);

   
        const WORDS = [];
const baseWords = [
  "üíñ Mi amor", "üåû Mi sol", "üåé Mi mundo", "‚ú® Brillas",
  "‚ù§Ô∏è Te amo", "üåå Universo", "üëë Reina", "üåü Estrella",
  "‚òÅÔ∏è Mi cielo", "üî• Siempre t√∫", "üòÇ Tu risa", "ü¶ã Libertad",
  "üíé Eres todo", "üôè Gracias", "üíï Cari√±o", "üåπ Amor eterno",
  "ü§ó Abrazos", "üå∏ Esperanza", "üåà Alegr√≠a", "üåü Contigo",
  "üß∏ Ternura", "üéÅ Mi raz√≥n", "üåô Mi destino", "üíå Recuerdos",
  "üïäÔ∏è Mi paz", "ü™ê Mi universo", "üåä Mi calma", "üí° Mi luz",
  "üçí Dulzura", "ü•∞ Mi vida", "üéá Felicidad", "üéà Alegr√≠a",
  "üå∫ Mi flor", "üíú Eternidad", "üå† Sue√±os", "‚ú® Magia",
  "üéµ Canci√≥n", "üî• Pasi√≥n", "‚≠ê Mi estrella", "üå¥ Mi para√≠so",
  "üåÑ Amanecer", "üåÉ Noche contigo", "üéâ Mi fiesta", "üí´ Inspiraci√≥n",
  "üå∑ Siempre juntos", "üéÄ Mi ternura", "üçÄ Mi fortuna", "ü™û Mi reflejo"
];

        for (let i = 0; i < 6; i++) {
            WORDS.push(...baseWords);
        }

        function makeTextTexture(text, shadowColor) {
            const canvas = document.createElement("canvas");
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext("2d");

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = "bold 60px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#fff";
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 30;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            return new THREE.CanvasTexture(canvas);
        }

        const COLORS = [
            "#ff66ff", "#66ccff", "#ffd36b", "#ff9966", "#8df59a",
            "#ffa0f8", "#c6a7ff", "#ff4444", "#44ff99", "#99ccff"
        ];

        const textGroup = new THREE.Group();
        scene.add(textGroup);

        for (let i = 0; i < WORDS.length; i++) {
            const texture = makeTextTexture(WORDS[i], COLORS[i % COLORS.length]);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);

            sprite.scale.set(50, 16, 1);

            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;
            const radius = 150 + 120 * Math.random();

            sprite.position.set(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );

            sprite.userData = {
                phi: phi,
                theta: theta,
                radius: radius,
                speed: 0.001 + 0.001 * Math.random()
            };

            textGroup.add(sprite);
        }

        // ===== CONTROLES DE ARRASTRE =====
        let dragging = false;
        let lastX = 0;
        let lastY = 0;

        function onDown(e) {
            dragging = true;
            const point = e.touches ? e.touches[0] : e;
            lastX = point.clientX;
            lastY = point.clientY;
        }

        function onMove(e) {
            if (!dragging) return;

            const point = e.touches ? e.touches[0] : e;
            const deltaX = (point.clientX - lastX) / innerWidth;
            const deltaY = (point.clientY - lastY) / innerHeight;

            rotY -= 3 * deltaX;
            rotX = Math.max(-1.2, Math.min(1.2, rotX + 2.2 * deltaY));

            lastX = point.clientX;
            lastY = point.clientY;
        }

        function onUp() {
            dragging = false;
        }

        addEventListener("mousedown", onDown);
        addEventListener("mousemove", onMove);
        addEventListener("mouseup", onUp);
        addEventListener("touchstart", onDown, { passive: true });
        addEventListener("touchmove", onMove, { passive: true });
        addEventListener("touchend", onUp, { passive: true });

        // ===== ZOOM CON RUEDA =====
        addEventListener("wheel", (e) => {
            targetDist += 0.25 * e.deltaY;
            targetDist = Math.max(160, Math.min(600, targetDist));
        }, { passive: true });

        // ===== ZOOM CON PINCH (M√ìVIL) =====
        let pinch = 0;

        addEventListener("touchmove", (e) => {
            if (e.touches && e.touches.length === 2) {
                e.preventDefault();

                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.hypot(dx, dy);

                if (pinch) {
                    targetDist += 0.5 * (pinch - dist);
                    targetDist = Math.max(160, Math.min(600, targetDist));
                }

                pinch = dist;
            }
        }, { passive: false });

        addEventListener("touchend", () => {
            pinch = 0;
        }, { passive: true });

        // ===== ANIMACI√ìN PRINCIPAL =====
        let t = 0;
        let colorPhase = 0;

        function tick() {
            requestAnimationFrame(tick);

            t += 0.01;
            colorPhase += 0.003; // Cambio suave de colores

            // Obtener nivel de audio para reactividad
            audioReactivity = getAudioLevel();
            const audioBoost = 1 + audioReactivity * 0.8;

            // Actualizar estrellas fugaces
            updateShootingStars();

            // Rotar anillos (m√°s r√°pido con m√∫sica)
            ring1.rotation.z += 0.002 + audioReactivity * 0.01;
            ring2.rotation.z -= 0.0015 + audioReactivity * 0.008;

            // ANILLOS REACTIVOS A LA M√öSICA
            const ring1Scale = 1 + audioReactivity * 0.3;
            const ring2Scale = 1 + audioReactivity * 0.25;
            ring1.scale.set(ring1Scale, ring1Scale, 1);
            ring2.scale.set(ring2Scale, ring2Scale, 1);
            ring1.material.opacity = 0.8 + audioReactivity * 0.2;
            ring2.material.opacity = 0.5 + audioReactivity * 0.3;

            // Rotar n√∫cleo lentamente
            core.rotation.y += 0.005 + audioReactivity * 0.02;
            core.rotation.x += 0.002;

            // Pulsar resplandor con efecto suave + reactividad
            const pulseFactor = 1 + 0.04 * Math.sin(0.5 * t) + 0.02 * Math.sin(1.3 * t) + audioReactivity * 0.2;
            const glowScale = 450 * pulseFactor;
            glow.scale.set(glowScale, glowScale, 1);
            glow2.scale.set(600 * (1 + 0.03 * Math.sin(0.3 * t + 1) + audioReactivity * 0.15), 600 * (1 + 0.03 * Math.sin(0.3 * t + 1) + audioReactivity * 0.15), 1);

            // Actualizar colores del resplandor
            if (Math.floor(t * 10) % 5 === 0) {
                glowMaterial.map = makePulsarGlow(768, colorPhase);
                glowMaterial.map.needsUpdate = true;
                glowMaterial2.map = makePulsarGlow(768, colorPhase + 1.5);
                glowMaterial2.map.needsUpdate = true;
            }

            // Pulsar n√∫cleo con reactividad de audio
            const coreScale = 1 + 0.08 * Math.sin(2.5 * t) + audioReactivity * 0.15;
            core.scale.set(coreScale, coreScale, coreScale);

            // Cambiar color del n√∫cleo suavemente
            const hue = (Math.sin(t * 0.2) + 1) / 2;
            coreMat.emissive.setHSL(0.75 - hue * 0.15, 0.8, 0.3);

            // Animar haces del pulsar con reactividad
            const beamPulse = 0.6 + 0.4 * Math.sin(4 * t) + audioReactivity * 0.5;
            beamTop.material.opacity = 0.3 * beamPulse;
            beamBottom.material.opacity = 0.3 * beamPulse;
            beamTop.scale.set(1 + 0.2 * Math.sin(3 * t) + audioReactivity * 0.5, 1 + audioReactivity * 0.3, 1 + 0.2 * Math.sin(3 * t) + audioReactivity * 0.5);
            beamBottom.scale.set(1 + 0.2 * Math.sin(3 * t) + audioReactivity * 0.5, 1 + audioReactivity * 0.3, 1 + 0.2 * Math.sin(3 * t) + audioReactivity * 0.5);


            beamTop.rotation.y += 0.02;
            beamBottom.rotation.y += 0.02;

            const beamGlowScale = 80 * (1 + 0.3 * Math.sin(4 * t));
            beamGlowTop.scale.set(beamGlowScale, beamGlowScale, 1);
            beamGlowBottom.scale.set(beamGlowScale, beamGlowScale, 1);

            textGroup.children.forEach((sprite) => {
                sprite.material.opacity = 0.8 + 0.2 * Math.sin(2 * t);
                sprite.userData.theta += sprite.userData.speed;

                sprite.position.x = sprite.userData.radius * Math.sin(sprite.userData.phi) * Math.cos(sprite.userData.theta);
                sprite.position.z = sprite.userData.radius * Math.sin(sprite.userData.phi) * Math.sin(sprite.userData.theta);
            });

 
            currentDist += 0.06 * (targetDist - currentDist);

            const cosX = Math.cos(rotX);
            const sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY);
            const sinY = Math.sin(rotY);

            camera.position.set(
                currentDist * sinY * cosX,
                currentDist * sinX,
                currentDist * cosY * cosX
            );
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        tick();
    </script>
    <footer>by: David AB (for Evelyn)</footer>
</body>
</html>